BONUS Ex3

New feature:

- Path scoring

Updated to already existing feature:

- Automatic testing

Path Scoring
============

IMPORTANT NOTE: the scoring method of a path is different from the scoring of an entire simulation.

Our algorithms rely heavily on getting the shortest path between two positions.
In previous assignments, we calculated the shortest path by simply running a BFS.
In this assignment, we decided to take a slightly different approach.

To find the shortest path between two positions, we create a path tree of *all* possible paths.
Each path has its own score, based on the number of unvisited/dirty positions in the path.
We then choose the shortest path which maximizes that number.

This method encourages the robot to explore unvisited positions opportunistically,
gathering additional information without sacrifising any step.

Example
-------

Suppose this is the state of our house (`R` represents the current position of the robot),
and all `0` positions have been visited, while `1` positions haven't:
D000
111R

There are 4 shortest paths to the station:
- WWWN
- WWNW
- WNWW
- NWWW

The first path maximizes the number of dirty/unvisited positions and therefore is chosen.

Automatic testing
=================

New tests introduces:
- RobotImmediateFinish
- RobotStepsTaken
- RobotIsWorkingNotInDock
- RobotIsWorkingInDock
- RobotIsLying

In addition, most tests and infra required significant refactoring to be able to run with the new code.

---------------------------------------------------------------------------------------------

BONUS Ex2

There are several updated to the already existing features:

- Visual simulation - complies with the new input/output files format.

- Automatic testing - infra and all tests were significantly refactored.
  In addtition, the following testes were created:

  - Algorithm module:
    - TooLowBatteryToClean
    - TooLowMaxStepsToClean
    - StopChargingToClean
  - Simulator module:
    - RobotFilledLine
    - RobotFilledCol
    - RobotDeterministic
    - RobotAPICallingOrder
    - RobotIsDead
    - RobotIsWorking

---------------------------------------------------------------------------------------------

BONUS Ex1

This file contains brief information about:

- Visual simulation

- Automatic testing

- Logging system

- Interesting implementation details:

  - Position hashing functions

Visual simulation
=================

Written in python3 and can be found in src/simulate.py.
Receives both input file as output file (previously created by myrobot) as inputs.
To run it, enter the following command: python3 src/simulate.py <inputfile> <outputfile>.
FPS can also be adjusted using the --fps flag.

Automatic testing
=================

Written in C++ using the GTest framework.
Contains both system and unit tests, with fixtures, mocking, and extra infrastructure as needed.
To run the tests, run the following commands from the root dir of the project:
mkdir build
cd build
cmake .. -DBUILD_TESTS=ON
ctest

More details about testing and validation can be found in the HLD file.

Logging system
==============

Besides the required output file generated by`myrobot`, we've developed a more shopisticated and robust logging system.
We created a general `Logger` singleton base class to accommodate future possible logging needs.
Additionaly, we implemented a `RobotLogger` derived class to adapt the `Logger` API to our specific usecases.
Our logging system supports multiple logging levels (INFO, WARNING, ERROR) to enhance log messages.
It also allows for logging to different files or the console.

Using a singleton design pattern offers several benefits:
1) Single logger instance ensures thread safety and prevents resource access races.
2) Simplifies usage by eliminating the need to pass the logger through function calls or reconfigure multiple instances.

Interesting implementation details
==================================

Position hashing function
-------------------------

Simply put, Position is a pair of integers (coordiantes) which represent a place in the house.
In our implementation, we use unordered collections of Position objects.
To do so, we must implement a hashing function, and we chose elegant pairing which is injective
and has a few more desired properties.
More information about it can be found in: src/position.h+63
